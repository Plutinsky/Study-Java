Создание собственных исключений будет рассмотрено позже в этой главе. 
Если в блоке try может быть сгенеририровано в разных участках кода не-сколько типов исключений, то необходимо наличие нескольких блоков catch, если только блок catch не обрабатывает все типы исключений.
###
/* пример # 1 : обработка двух типов исключений: TwoException.java */ package chapt08;
public class TwoException {
public static void main(String[] args) { try {
int a = (int)(Math.random() * 2); System.out.println("a = " + a); int c[] = { 1/a };
c[a] = 71;
} catch(ArithmeticException e) { System.err.println("деление на 0" + e);
} catch(ArrayIndexOutOfBoundsException e) { System.err.println(
"превышение границ массива: " + e); }//последний catch
System.out.println("после блока try-catch");
}
}
@@@
Исключение "деление на 0" возникнет при инициализации элемента мас-сива а=0. В противном случае (при а=1) генерируется исключение "превыше-ние границ массива" при попытке присвоить значение второму элементу массива с[], который содержит только один элемент. Однако пример, приве-денный выше, носит чисто демонстративный характер и не является образцом хорошего кода, так как в этой ситуации можно было обойтись простой провер-кой аргументов на допустиые значения перед выполнением операций. К тому же генерация и обработка исключения – операция значительно более ресурсоемкая, чем вызов оператора if для проверки аргумента. Исключения должны приме-няться только для обработки исключительных ситуаций, и если существует воз-можность обойтись без них, то следует так и поступить.
Подклассы исключений в блоках catch должны следовать перед любым из их суперклассов, иначе суперкласс будет перехватывать эти исключения.
###
Например: try {/*код, который может вызвать исключение*/} 
catch(RuntimeException e) { /* суперкласс RuntimeException
перехватит объекты всех своих подклассов */
} catch(ArithmeticException e) {} /* не может быть вызван,
поэтому возникает ошибка компиляции */
@@@
Операторы try можно вкладывать друг в друга. Если у оператора try низ-кого уровня нет раздела catch, соответствующего возникшему исключению, поиск будет развернут на одну ступень выше, и будут проверены разделы catch внешнего оператора try.
В результате запуска приложения при a=0 будет сгенерировано исключе-ние ArithmeticException, а подходящий для его обработки блок try– catch является внешним по отношению к месту генерации исключения. Этот блок и будет задействован для обработки возникшей исключительной ситуа-ции.
Третий подход к обработке исключений будет рассмотрен ниже на примере создания пользовательских исключений.


